@Chapter Weyl modules
@ChapterLabel Weyl_modules

This chapter discusses the commands available for computations with
Weyl modules for a given simple simply-connected algebraic group $G$
in positive characteristic $p$. Actually the group $G$ itself never
appears in any of the computations, which take place instead using the
**algebra of distributions** (also known as the **hyperalgebra**) of
$G$, taken over the prime field. One should refer to <Cite
Key="Jantzen"/> for the definition of the algebra of distributions,
and other basic definitions and properties related to Weyl modules.

The algorithms are based on the method of <Cite Key = "Irving"/> (see
also <Cite Key = "Xi"/>) and build on the existing Lie algebra
functionality in &GAP;. In principle, one can work with arbitrary
weights for an arbitrary (simple) root system; in practice, the
functionality is limited by the size of the objects being computed.
If your Weyl module has dimension in the thousands, you may have to
wait a very long time for certain computations to finish.

The package is possibly most useful for doing computations in
characteristic $p$, where $p$ is relatively small relative to the
Coxeter number.  The general theory of Weyl modules <Cite
Key="Jantzen"/> includes a number of basic properties that break down
(or are not known to hold) if the characteristic is too small. In such
cases, explicit computations are often useful.

Recall that a **maximal vector** is a weight vector which is killed by
the positive unipotent radical; equivalently, it is killed by the
positive part of the algebra of distributions.

The main technical idea underlying this package is the following fact:
computing all the maximal vectors in a given Weyl module $V$
classifies the nonzero Weyl modules $W$ for which a nonzero
homomorphism from $W$ into $V$ exists. Such homological information is
a powerful aid to understanding structural properties of the Weyl
module $V$. The implementation of this idea involves a brute force
search through each dominant weight space, examing all linear
combinations (over the prime field) and compiling a list of the ones
which are maximal. This exploits the pleasant fact that for Weyl
modules of small dimension, the dimension of the weight spaces tends
to be manageable.


**Warning.** In most cases, the dimension of space of maximal vectors
of a given dominant weight is either $0$ or $1$. Cases for which there
exist two or more independent maximal vectors of the same weight can
lead to complications, such as a lack of rigidity in the submodule
structure.  Such situations are relatively rare (and interesting); the
smallest example known to the author occurs in Type $D_4$ in the Weyl
module of highest weight $[0,1,0,0]$, as pointed out on page 173 of
<Cite Key = "CPS"/>. (I am grateful to Anton Cox for this reference.)

A Weyl module (as in the previous paragraph) with at least one weight
space containing multiple (linearly independent) maximal vectors is
called **ambiguous**. Extra care is needed when studying ambiguous
Weyl modules.


@Section Creating Weyl modules
There are two functions for creating a Weyl module.

<Verb>
WeylModule( p, wt, type, rank )
WeylModule( V, wt )
</Verb>
In both forms <A>wt</A> is the highest weight of the Weyl module.  The
function with four arguments specifies the characteristic <A>p</A>,
the root system <A>type</A> (a letter in the range A--G) and its
<A>rank</A>. In the second form, with two arguments, the function gets
the characteristic and underlying root system from an existing Weyl
module <A>V</A>.

@BeginExampleSession
gap> V:= WeylModule(3, [3,4], "A", 2);
<Type A2 Weyl module of highest weight [ 3, 4 ] at prime p = 3>
gap> W:= WeylModule(V, [3,0]);
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
@EndExampleSession
There is also a category of Weyl modules.
<Verb>
IsWeylModule( V )
</Verb>
This returns true if <A>V</A> is a Weyl module and returns false
otherwise.

@BeginExampleSession
gap> IsWeylModule(W);
true
gap> IsWeylModule(4);
false
@EndExampleSession


@Section Creating quotient Weyl modules

Quotients of an existing Weyl module by a submodule are supported.
See Section <Ref Sect="Chapter_Weyl_modules_Section_Creating_submodules"/>
below for methods that create submodules.

<Verb>
QuotientWeylModule( S )
DefiningKernel( Q )
</Verb>
The first function returns the quotient module <A>V</A>/<A>S</A>,
where <A>V</A> is the ambient Weyl module of which <A>S</A>
is a submodule. In the latter function, <A>Q</A> must be an
existing quotient Weyl module and its kernel (a submodule) is
returned.

@BeginExampleSession
gap> Q := QuotientWeylModule(D);
<Quotient of Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
@EndExampleSession
In the above, it is assumed that $D$ is the submodule constructed in
the second example of Section
<Ref Sect="Chapter_Weyl_modules_Section_Creating_submodules"/> below.

There is also a category of quotient Weyl modules.

<Verb>
gap> IsQuotientWeylModule( Q )
</Verb>
which returns true if $Q$ is a quotient Weyl module, and returns false
otherwise.



@Section Creating submodules

The &WeylModules; package includes support for working with
submodules. Submodules of ambient modules are created by specifying
either a single generator or a list of generators; in the latter case
the submodule is the linear sum of the submodules generated by the
vectors on the list. The ambient module can be: a Weyl module, a
quotient of a Weyl module, or an existing submodule of either a Weyl
module or a quotient Weyl module.

<Verb>
SubWeylModule( V, vec )
SubWeylModule( V, lst )
</Verb>
This returns a submodule of the given ambient object <A>V</A> of one of
the forms described above.
If the second argument <A>vec</A> is a vector, then it returns the
submodule of <A>V</A> generated by that vector. If the second argument
is a list <A>lst</A> then it returns the submodule generated by that
list of vectors.

WARNING: If the dimension of the ambient module is large, this can
take a very long time.

@BeginExampleSession
gap> V := WeylModule(3,[3,3],"A",2);
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
gap> List(m,Weight);
[ [ 3, 3 ], [ 1, 4 ], [ 4, 1 ], [ 0, 3 ], [ 3, 0 ], [ 1, 1 ] ]
gap> S := SubWeylModule(V, m[6]);
<SubWeylModule of dimension 7, generated by elements 
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ] of weights [ [ 1, 1 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> S2 := SubWeylModule(V, [m[4],m[5]]);
<SubWeylModule of dimension 13, generated by elements 
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0 ] of weights [ [ 0, 3 ], [ 3, 0 ] 
 ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
@EndExampleSession


An existing submodule remembers its list of generators.

<Verb>
Generators( S )
</Verb>
returns the list of generators used in creating the submodule <A>S</A>.
Here, <A>S</A> must be either a sub Weyl module or a subquotient.

@BeginExampleSession
gap> Generators(S2);
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0 ]
@EndExampleSession
In the above example, it is assumed that <K>S2</K> is the submodule
constructed in the preceding example.

There is another function that creates submodules of an existing
Weyl module or quotient Weyl module, as a direct sum of a list of
existing submodules. The submodules in the list must be linearly
independent.

<Verb>
SubWeylModuleDirectSum( V, lst )
</Verb>
This returns the direct sum of the given list of submodules, as a submodule
of the ambient module <A>V</A>.

@BeginExampleSession
gap> V := WeylModule(2,[2,0],"G",2);
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y4*v0 ]
gap> List(m,Weight);
[ [ 2, 0 ], [ 0, 1 ], [ 1, 0 ] ]
gap> S1 := SubWeylModule(V,m[2]);
<SubWeylModule of dimension 14, generated by elements [ y1*v0 ] of weights 
[ [ 0, 1 ] ]>, in
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> S2 := SubWeylModule(V,m[3]);
<SubWeylModule of dimension 6, generated by elements [ y4*v0 ] of weights 
[ [ 1, 0 ] ]>, in
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> D := SubWeylModuleDirectSum(V,[S1,S2]);
<SubWeylModule of dimension 20, generated by elements 
[ y1*v0, y4*v0 ] of weights [ [ 0, 1 ], [ 1, 0 ] ]>, in
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
@EndExampleSession
In the above example, the given Weyl module of type $G_2$ in
characteristic $2$ has two maximal vectors of different weights in the
socle, so it is possible to form the direct sum of the submodules thay
generate. In this case, the direct sum coincides with the socle.
(The <K>SocleWeyl</K> command calls the above to produce
the socle directly.)  

We also have categories of submodules.

<Verb>
IsSubWeylModule ( X )
IsSubQuotientWeylModule( X )
</Verb>
These functions return true if the object is a submodule of an existing
Weyl module or existing quotient Weyl module, respectively, and return
false otherwise.

@BeginExampleSession
gap> IsSubWeylModule(D);
true
gap> IsSubQuotientWeylModule(D);
false
@EndExampleSession
Here, we assume that $D$ is as defined in the preceding example.




@Section Weights and weight spaces

The following functions are available for computing weights
and weight spaces in a given Weyl module, quotient, submodule,
or subquotient.
<Verb>
Weight( vec )
Weights( V )
DominantWeights( V )
WeightSpaces( V )
DominantWeightSpaces( V )
WeightSpace( V, wt )
</Verb>
The function <K>Weight</K> returns the weight of the given weight
vector <A>vec</A>. <K>Weights</K> returns a list of all the weights
of <A>V</A>, without multiplicities. <K>DominantWeights</K> returns
a list of all the dominant weights of <A>V</A>, again without
multiplicities.
<K>WeightSpaces</K> returns a list consisting of each weight
followed by a basis of weight vectors for the corresponding weight
space in <A>V</A>, and <K>WeightSpace</K> returns a basis for the
weight space of the given weight <A>wt</A>.

In all of these functions, <A>V</A> can be an existing Weyl module,
quotient Weyl module, submodule, or subquotient.

@BeginExampleSession
gap> V:= WeylModule(2, [1,0,0], "A", 3);
<Type A3 Weyl module of highest weight [ 1, 0, 0 ] at prime p = 2>
gap> Weights(V);
[ [ 1, 0, 0 ], [ -1, 1, 0 ], [ 0, -1, 1 ], [ 0, 0, -1 ] ]
gap> DominantWeights(V);
[ [ 1, 0, 0 ] ]
gap> WeightSpaces(V);
[ [ 1, 0, 0 ], [ 1*v0 ], [ -1, 1, 0 ], [ y1*v0 ], [ 0, -1, 1 ], [ y4*v0 ],
[ 0, 0, -1 ], [ y6*v0 ] ]
gap> DominantWeightSpaces(V);
[ [ 1, 0, 0 ], [ 1*v0 ] ]
gap> WeightSpace(V, [-1,1,0]);
[ y1*v0 ]
gap> WeightSpace(V, [0,1,0]);
fail
@EndExampleSession
The last command prints <K>fail</K> because there are no weight
vectors of weight [0,1,0] in the indicated Weyl module.


@Subsection Using <K>List</K> with <K>Weight</K>

The builtin <K>List</K> function in &GAP; supports mapping with respect to
another function as an optional second argument.
If <A>lst</A> is a given list of weight vectors (for
instance a basis of a module) then the function
<Verb>
List( lst, Weight )
</Verb>
returns a list of the weights of the vectors in <A>lst</A>.
In other words, it applies <K>Weight</K> to each element in <A>lst</A>.
This can be very handy.

@BeginExampleSession
gap> N := WeylModule(2,[1,0],"A",2);
<Type A2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
gap> base := BasisVecs(N);
[ 1*v0, y1*v0, y3*v0 ]
gap> List(base,Weight);
[ [ 1, 0 ], [ -1, 1 ], [ 0, -1 ] ]
@EndExampleSession
In the above, we compute a basis of weight vectors and the corresponding
list of weights for the natural module of type $A_2$.



@Section Maximal vectors

As mentioned at the beginning of this chapter, the commands to compute
maximal vectors are fundamental for the &WeylModules; package.
The command has two basic forms.
In both forms, <A>V</A> is a given Weyl module, quotient
Weyl module, or sub quotient Weyl module. In the second form,
<A>wt</A> is a specified (dominant) weight.

<Verb>
MaximalVectors( V )
MaximalVectors( V, lst )
</Verb>
This command returns a list of maximal vectors in the specified
weight space, or, if no weight is specified, a list of all the maximal
vectors in the module.

@BeginExampleSession
gap> V := WeylModule(3,[3,3],"A",2);
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
gap> List(m,Weight);
[ [ 3, 3 ], [ 1, 4 ], [ 4, 1 ], [ 0, 3 ], [ 3, 0 ], [ 1, 1 ] ]
m11 := MaximalVectors(V,[1,1]);
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
@EndExampleSession

There is also a function for testing a given vector in a Weyl module or
a quotient Weyl module, to see if it is maximal or not.
<Verb>
IsMaximalVector( V, vec )
</Verb>
This returns true of the given <A>vec</A> is maximal in <A>V</A>,
which can be a Weyl module or a quotient Weyl module, and returns false
otherwise.

@BeginExampleSession
gap> V;
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> m[5];
-1*y1*y2^(2)*v0+y2*y3*v0
gap> IsMaximalVector(V,m[5]);
true
@EndExampleSession
The above assumes that $V$ is the Weyl module defined in the previous
example, and that $m$ is the list of its maximal vectors.


@Section Ambiguity

Recall from the beginning of this chapter that we defined an **ambiguous**
Weyl module to be one which has a weight space containing at least two
linearly independent maximal vectors. Extra care is needed when computing
with such modules, so the <K>MaximalVectors</K> function produces a
warning message and tags the module as <K>Ambiguous</K>. Here is an example,
which was found in <Cite Key="CPS"/>.

@BeginExampleSession
gap> V := WeylModule(2,[0,1,0,0],"D",4);
<Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2>
gap> m := MaximalVectors(V);
***** WARNING: Ambiguous module detected *****
[ 1*v0, y5*y10*v0+y6*y9*v0, y2*y11*v0+y5*y10*v0+y12*v0 ]
@EndExampleSession

In such situations, the following commands can be used.
<Verb>
IsAmbiguous( V )
AmbiguousMaxVecs( V )
</Verb>
The first function, which returns true or false, checks to see if the
given module <A>V</A> is ambiguous. The second function returns a list
of lists of the ambiguous maximal vectors in the various ambiguous
weight spaces. In both functions, <A>V</A> is a Weyl
module, quotient, submodule. (WHY NOT subquotient??)

@BeginExampleSession
gap> IsAmbiguous(V);
true
gap> m := AmbiguousMaxVecs(V);
[ [ y5*y10*v0+y6*y9*v0, y2*y11*v0+y5*y10*v0+y12*v0 ] ]
gap> List(m[1],Weight);
[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]
@EndExampleSession
Here, we see that $V$ as above has two maximal vectors of weight zero.
This means that the space of homomorphisms from the trivial module
into $V$ is two-dimensional.

@Section Basis and dimension

One can compute the dimension or a basis of weight vectors for a
given module.  

<Verb>
Dim( V )
BasisVecs( V )
</Verb>
This returns the dimension and a list of weight vectors, resprectively.
The module <A>V</A> must be a Weyl module, a submodule, a quotient, or a
subquotient.

@BeginExampleSession
gap> V:= WeylModule(2, [1,0], "G", 2);
<Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
gap> b:= BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
gap> Dim(V);
7
@EndExampleSession


@Section Miscellaneous commands

There are a few additional commands available for a Weyl module
or a quotient Weyl module.

<Verb>
Generator( V )
TheLieAlgebra( V )
SimpleLieAlgGens( V )
TheCharacteristic( V )
</Verb>
These commands respectively return the generator, the underlying Lie algebra,
a list of the Lie algebra generators, and the characteristic.
The third function is only available for a Weyl module (it is used internally
by some of the other functions).
The Lie algebra is the **characteristic zero** Lie
algebra of the same type as the underlying algebraic group. The module
<A>V</A> must be either a Weyl module or a quotient Weyl module.

@BeginExampleSession
gap> V:= WeylModule(2, [1,0], "G", 2);
<Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
gap> TheLieAlgebra(V);
<Lie algebra of dimension 14 over Rationals>
gap> g:= Generator(V);
1*v0
gap> TheCharacteristic(V);
2
@EndExampleSession


@Chapter Characters and structure

Given a Weyl module, one can compute certain structural information
such as its socle series or its unique simple quotient. One can also
compute characters of Weyl modules, quotients, submodules, and
subquotients. Characters of tensor products are also
supported, in a limited way.

In particular, it is possible to compute all the simple characters for
a given root system and characteristic, provided the modules do not
get too large. And one can compute the decomposition numbers for a
given Weyl module, again assuming it is not too large.


@Section Characters

The most basic command to compute the character of an existing module is the
following.

<Verb>
Character( V )
</Verb>
This returns a list consisting of each weight of <A>V</A> followed by its
corresponding weight space dimension.
The module <A>V</A> must be a Weyl module, a submodule, a quotient,
or a subquotient.

@BeginExampleSession
gap> V:= WeylModule(3, [3,0], "A", 2);
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> Character(V);
[ [ 3, 0 ], 1, [ 1, 1 ], 1, [ 2, -1 ], 1, [ -1, 2 ], 1, [ 0, 0 ], 1, 
  [ -3, 3 ], 1, [ 1, -2 ], 1, [ -2, 1 ], 1, [ -1, -1 ], 1, [ 0, -3 ], 1 ]
gap> S:= MaximalSubmodule(V);
<SubWeylModule of dimension 7, generated by elements [ y1*v0 ] of weights 
[ [ 1, 1 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> Character(S);
[ [ 1, 1 ], 1, [ -1, 2 ], 1, [ 2, -1 ], 1, [ 0, 0 ], 1, [ -2, 1 ], 1, 
  [ 1, -2 ], 1, [ -1, -1 ], 1 ]
gap> Character(QuotientWeylModule(S));
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
@EndExampleSession

Simple characters for a given highest (dominant) weight are computed
by one of the following.

<Verb>
SimpleCharacter( p, wt, type, rk )
SimpleCharacter( V, wt )
</Verb>
These return the simple character of the given highest weight.
In the second form, <A>V</A> must be an existing Weyl module,
and the characteristic <A>p</A>, the type <A>type</A>, and the
rank <A>rk</A> are looked up in <A>V</A>.
(Note: In the second form, the highest weight
<A>wt</A> does not have to agree with the highest weight of <A>V</A>.)

@BeginExampleSession
gap> char:= SimpleCharacter(3, [3,0], "A", 2);
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
gap> V:= WeylModule(2, [1,0], "G", 2);
<Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
gap> char := SimpleCharacter(V,[0,2]);
[ [ 0, 2 ], 1, [ 6, -2 ], 1, [ 2, 0 ], 1, [ -2, 2 ], 1, [ -6, 4 ], 1, 
  [ 4, -2 ], 1, [ 0, 0 ], 2, [ 6, -4 ], 1, [ -4, 2 ], 1, [ 2, -2 ], 1, 
  [ -2, 0 ], 1, [ -6, 2 ], 1, [ 0, -2 ], 1 ]
@EndExampleSession


Characters can be multiplied.
Given two characters (of modules) for the same root system, it is possible to
compute the character of the tensor product of the modules.
This is used internally in implementing Steinberg's tensor product theorem.

<Verb>
ProductCharacter( ch1, ch2 )
</Verb>
Returns the product character. 

@BeginExampleSession
gap> V := WeylModule(3,[1,1],"A",2);
<Type A2 Weyl module of highest weight [ 1, 1 ] at prime p = 3>
gap> ch1 := SimpleCharacter(V,[0,1]);
[ [ 0, 1 ], 1, [ 1, -1 ], 1, [ -1, 0 ], 1 ]
gap> prod := ProductCharacter(ch1,ch1);
[ [ 0, 2 ], 1, [ 1, 0 ], 2, [ -1, 1 ], 2, [ 2, -2 ], 1, [ 0, -1 ], 2, 
  [ -2, 0 ], 1 ]
@EndExampleSession

It is possible to subtract characters. The result is not in general
a character. The function <K>DecomposeCharacter</K> uses character
subtraction to decompose a given character into its simple characters
with multiplicity. This is used internally by the
<K>DecompositionNumbers</K> function to compute the decomposition
numbers of a Weyl module.

<Verb>
DifferenceCharacter( ch1, ch2 )
DecomposeCharater( ch, p, type, rk )
</Verb>
The first function returns the virtual character of the difference of its
inputs. The second computes the decomposition numbers
of the given charaacter <A>ch</A> for the root system
of type <A>type</A>, rank <A>rk</A>, and characteristic <A>p</A>.

@BeginExampleSession
gap> d := DecomposeCharacter(prod,3,"A",2);
[ [ 0, 2 ], 1, [ 1, 0 ], 1 ]
gap> V := WeylModule(3,[1,1],"A",2);
<Type A2 Weyl module of highest weight [ 1, 1 ] at prime p = 3>
gap> dn := DecomposeCharacter(Character(V),3,"A",2);
[ [ 1, 1 ], 1, [ 0, 0 ], 1 ]
@EndExampleSession
In the first example, <K>prod</K> is the product character computed in the
previous example; thus we have decomposed a tensor product.
In the last example,
<K>dn</K> gives the decomposition numbers
of the Weyl module of highest weight [1,1] in characteristic $3$.
(This can also be computed more directly by the
<K>DecompositionNumbers</K> function.)


@Section Decomposition numbers

The decomposition numbers of a given Weyl module can be computed.

<Verb>
DecompositionNumbers( V )
</Verb>
This returns a list consisting of each highest weight of a simple
composition factor followed by its composition factor multiplicity.
It is assumed that <A>V</A> is an existing Weyl module. (There are
other ways to compute this, so the function is provided as a
convenience for the user.)

@BeginExampleSession
gap> V := WeylModule(3,[3,3],"A",2);
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> DecompositionNumbers(V);
[ [ 3, 3 ], 1, [ 1, 4 ], 1, [ 4, 1 ], 1, [ 0, 3 ], 1, [ 3, 0 ], 1, [ 1, 1 ], 
  1, [ 0, 0 ], 2 ]
@EndExampleSession


@Section The maximal submodule and simple quotient

A given Weyl module <A>V</A> always has a unique maximal
submodule. The package supports computing this important submodule.

<Verb>
MaximalSubmodule( V )
</Verb>
This returns the submodule generated by all proper submodules.

@BeginExampleSession
gap> V := WeylModule(3,[3,0],"A",2);
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> S := MaximalSubmodule(V);
<SubWeylModule of dimension 7, generated by elements [ y1*v0 ] of weights 
[ [ 1, 1 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
@EndExampleSession
Here, the Weyl module is the third symmetric power of the natural module.
It has dimension $10$. The maximal submodule makes a list of its generators
available to the <K>Generators</K> function for further computation.

Let's check that the difference character of the Weyl character
and its maximal submodule coincides with the corresponding simple character.
@BeginExampleSession
gap> d := DifferenceCharacter(Character(V),Character(S));
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
gap> s := SimpleCharacter(3,[3,0],"A",2);
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
@EndExampleSession

We can also compute the corresponding simple quotient of <A>V</A>
by its maximal submodule, as a quotient Weyl module. The general form is

<Verb>
SimpleQuotient( V )
</Verb>
This returns the simple quotient of a Weyl module <A>V</A> by its
unique maximal submodule.

@BeginExampleSession
gap> V := WeylModule(3,[3,0],"A",2);
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> Q := SimpleQuotient(V);
<Quotient of Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> ch := Character(Q);
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
@EndExampleSession
Notice that this gives yet another way to calculate simple characters.


@Section The socle series

The package supports computing the socle series of a given Weyl module, or
of a given quotient Weyl module.

<Verb>
SocleSeries( V )
</Verb>
This returns the socle series, as a list of submodules
(or a list of subquotients, if <A>V</A> is a quotient Weyl module).

@BeginExampleSession
gap> V := WeylModule(3,[3,0],"A",2);
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> SocleSeries(V);
[ <SubWeylModule of dimension 7, generated by elements [ y1*v0 ] of weights 
    [ [ 1, 1 ] ]>, in
    <Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>, 
  <SubWeylModule of dimension 10, generated by elements 
    [ y1*v0, 1*v0 ] of weights [ [ 1, 1 ], [ 3, 0 ] ]>, in
    <Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3> ]
@EndExampleSession

The socle series is computed by internally applying the following
functions, which may be useful in other situations as well.

<Verb>
SocleWeyl( V )
NextSocle( S )
GensNextSocle( S )
</Verb>
The first function returns the socle of its argument. The second function
returns the next socle layer, assuming that <A>S</A> is a submodule. That
is, <K>NextSocle</K> returns the submodule that maps onto the socle of
the quotient <A>V</A>/<A>S</A>, where <A>V</A> is the ambient module.
The third function returns a list of generators of the next socle layer
for the given submodule <A>S</A>. For the first two functions, <A>V</A>
must be either a Weyl module or a quotient Weyl module.
The third function is only available for a Weyl module.

@BeginExampleSession
gap> soc := SocleWeyl(V);
<SubWeylModule of dimension 7, generated by elements 
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ] of weights [ [ 1, 1 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
@EndExampleSession

@BeginExampleSession
gap> V := WeylModule(3,[3,3],"A",2);
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
gap> S := SubWeylModule(V,[m[4],m[5]]);
<SubWeylModule of dimension 13, generated by elements 
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0 ] of weights [ [ 0, 3 ], [ 3, 0 ] 
 ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> N := NextSocle(S);
<SubWeylModule of dimension 14, generated by elements 
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, y1*y2*y3^(2)*v0 ] of weights 
[ [ 0, 3 ], [ 3, 0 ], [ 0, 0 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> gens := GensNextSocle(S);
[ y1*y2*y3^(2)*v0 ]
@EndExampleSession


@Section Testing membership

It is possible to test a given weight vector for membership in a submodule
or a subquotient.

<Verb>
IsWithin( S, vec )
</Verb>
This returns true if the given vector <A>vec</A> is in the
submodule <A>S</A>, and returns false otherwise.
The vector <A>vec</A> must be in the ambient module.
Here, <A>S</A> can be either a submodule of a Weyl module,
or a submodule of a quotient Weyl module.

@BeginExampleSession
gap> V := WeylModule(3,[3,3],"A",2);
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> M := MaximalSubmodule(V);
<SubWeylModule of dimension 57, generated by elements 
[ y1*v0, y2*v0, y1^(3)*y2^(3)*v0+y3^(3)*v0 ] of weights 
[ [ 1, 4 ], [ 4, 1 ], [ 0, 0 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
gap> IsWithin(M,m[1]);
false
gap> IsWithin(M,m[2]);
true
gap> IsWithin(M, m[2]+2*m[3]);
true
@EndExampleSession



@Section The ambient module

Submodules and quotient modules remember the original ambient Weyl modules
from which they were constructed. Subquotients, which are always
constructed as submodules in some quotient Weyl module, know the
ambient quotient in which they were constructed. The following functions
return the ambient module to make it available for further computations.

<Verb>
AmbientWeylModule( M )
AmbientQuotient( S )
</Verb>
In the first function, <A>M</A> can be either a quotient Weyl module
or a submodule of a Weyl module, and the ambient Weyl module is returned.
In the second function, <A>M</A> must be a submodule of some existing
quotient Weyl module, and the ambient quotient is returned.

@BeginExampleSession
gap> V := WeylModule(2,[0,1,0,0],"D",4);
<Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2>
gap> S := SocleWeyl(V);
***** WARNING: Ambiguous module detected *****
<SubWeylModule of dimension 2, generated by elements 
[ y5*y10*v0+y6*y9*v0, y2*y11*v0+y5*y10*v0+y12*v0 ] of weights 
[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]>, in
<Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2>
gap> AmbientWeylModule(S);
<Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2>
@EndExampleSession


@Section Acting on a vector

It is sometimes useful to act on a given vector by an element of
the hyperalgebra (algebra of distributions).
One needs to use a builtin &GAP; function to construct elements
of the hyperalgebra.

<Verb>
ActOn( V, u, vec )
</Verb>
This returns the result, in the ambient module <A>V</A>,
of letting <A>u</A> act on the given vector <A>vec</A>, where <A>V</A>
is either a Weyl module or a quotient Weyl module.


@BeginExampleSession
gap> V:= WeylModule(2, [1,0], "G", 2);
<Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
gap> L:= TheLieAlgebra(V);
<Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
gap> g:= LatticeGeneratorsInUEA(L);
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
gap> ActOn(V, g[1]^2 + g[7], b[1]);
0*v0
gap> ActOn(V, g[1]*g[6], b[1]);
y1*y6*v0
@EndExampleSession
Note that <K>LatticeGeneratorsInUEA</K> is an existing &GAP; command.


@Chapter Schur algebras and symmetric groups

The decomposition numbers for the algebraic group $SL_n$ of type $A_{n−1}$
determine the decomposition numbers for the corresponding Schur algebras,
and thus also determine the decomposition numbers for symmetric
groups. People working with Schur algebras and symmetric groups
often prefer to use **partitions** to label highest weights.
Although it is trivial to convert between $SL_n$ weight notation
and partition notation, for the sake of convenience,
we provide a few functions that perform such conversions,
and various other functions related to Schur algebras and symmetric groups.

It should be noted that the functions for symmetric groups are quite slow,
so readers interested in symmetric group computations may want to
look elsewhere for better tools.

@Section Compositions and weights

A (weak) **composition** of degree $r$ is a finite sequence $c = [c_1
, \dots , c_n ]$ of non-negative integers which add up to $r$. The
number $n$ of parts of $c$ is called its **length**. Note that zeros
are allowed in weak compositions, which are called compositions from now on.

One may identify the set of compositions of length $n$ with
the set of polynomial weights of the algebraic group $GL_n$.
Note that a composition is a partition if and only if it is a
dominant weight relative to the diagonal maximal
torus in $GL_n$.

<Verb>
CompositionToWeight( c )
WeightToComposition( r , wt )
</Verb>
<K>CompositionToWeight</K> converts a given list <A>c</A> (of length $n$)
into an $SL_n$ weight, by taking successive differences in the parts
of <A>c</A>. This produces a list of length $n-1$.
<K>WeightToComposition</K> does the reverse operation,
padding with zeros if necessary in order to return a
composition of degree $r$.
The degree must be specified since it is not uniquely determined by the given
weight. (The degree is unique modulo $n$.)
The length $n$ of the output is always one more than the length
of the input.

As a special case, these operations take partitions to dominant
weights, and vice versa.

@BeginExampleSession
gap> wt:= CompositionToWeight( [3,3,2,1,1,0,0] );
[ 0, 1, 1, 0, 1, 0 ]
gap> WeightToComposition(10, wt);
[ 3, 3, 2, 1, 1, 0, 0 ]
gap> WeightToComposition(17, wt);
[ 4, 4, 3, 2, 2, 1, 1 ]
@EndExampleSession


@Section Bounded partitions

There are two functions that compute lists of bounded partitiuons.

<Verb>
BoundedPartitions( n, r, s )
BoundedPartitions( n, r )
</Verb>
The first form returns a list of all partitions of <A>n</A> parts
in degree <A>r</A> whose parts lie in the closed interval $[0,s]$.
The second form is equivalent to the first where $s = r$; that is,
it returns a list of all of <A>n</A> parts
in degree <A>r</A>.


@BeginExampleSession
gap> BoundedPartitions(4,3,2);
[ [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
gap> BoundedPartitions(4,3,3);
[ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
gap> BoundedPartitions(4,3);
[ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
gap> BoundedPartitions(4,4,4);
[ [ 4, 0, 0, 0 ], [ 3, 1, 0, 0 ], [ 2, 2, 0, 0 ], [ 2, 1, 1, 0 ],
[ 1, 1, 1, 1 ] ]
@EndExampleSession
Notice that we sometimes allow zero parts in partitions.



@Section Listing partitions

We can also compute a list of all partitions of a given degree.

<Verb>
AllPartitions( r )
</Verb>
This returns a list of all the partitions of <A>r</A>, where zero parts
are not allowed.

@BeginExampleSession
gap> AllPartitions(4);
[ [ 4 ], [ 3, 1 ], [ 2, 2 ], [ 2, 1, 1 ], [ 1, 1, 1, 1 ] ]
@EndExampleSession


One can also calculate lists of $p$-restricted and $p$-regular partitions,
where $p$ is a given prime.

<Verb>
pRestrictedPartitions( p, n )
pRegularPartitions( p, n )
</Verb>
Here <A>p</A> is the characteristic and <A>n</A> the degree.


@BeginExampleSession
gap> pRestrictedPartitions(2,5);
[ [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
gap> pRegularPartitions(2,5);
[ [ 3, 2 ], [ 4, 1 ], [ 5 ] ]
@EndExampleSession


Finally, we have functions that test a given partition to check whether or
not it is restricted or regular with respect to a given prime.

<Verb>
pRestricted( p, ptn )
pRegular( p, ptn )
</Verb>
The functions return true if the given partition <A>ptn</A> is $p$-restricted
or $p$-regular, respectively, and return false otherwise. The characteristic
is <A>p</A>.


@BeginExampleSession
gap> pRestricted(2,[2,2,1]);
true
gap> pRestricted(2,[3,1]);
false
gap> pRegular(2,[3,2]);
true
gap> pRegular(2,[2,2,1]);
false
@EndExampleSession



@Section Schur algebras

There are only a few functions for working directly with Schur algebra
Weyl modules.

<Verb>
SchurAlgebraWeylModule( p, lambda )
</Verb>
This returns a Weyl module of highest weight <A>lambda</A> in
characteristic <A>p</A>, regarded as a
module for $GL_n$ where $n$ is the length of the given
partition <A>lambda</A>. Note that zero parts are allowed
in <A>lambda</A>.

@BeginExampleSession
gap> V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);
<Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3>
@EndExampleSession

There is also a category of Schur algebra Weyl modules.

<Verb>
IsSchurAlgebraWeylModule( V )
</Verb>
This returns true if the given <A>V</A> belongs to the category,
and returns false otherwise.

It is possible to compute the decomposition numbers of a Schur algebra Weyl
module, and the result is returned using partition notation.

<Verb>
DecompositionNumbers( V )
</Verb>
This returns a list consiting of each highest weight of a
composition factor (in partition notation) followed by its
corresponding composition factor multiplicity.

@BeginExampleSession
gap> V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);
<Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3>
gap> DecompositionNumbers(V);
[ [ 2, 2, 1, 1, 0 ], 1 ]
gap> V:= SchurAlgebraWeylModule(2, [4,2,1,1,0]);
<Schur algebra Weyl module of highest weight [ 4, 2, 1, 1, 0 ] at prime p = 2>
gap> DecompositionNumbers(V);
[ [ 4, 2, 1, 1, 0 ], 1, [ 3, 3, 1, 1, 0 ], 1, [ 3, 2, 2, 1, 0 ], 1,
[ 4, 1, 1, 1, 1 ], 1, [ 2, 2, 2, 2, 0 ], 1, [ 2, 2, 2, 1, 1 ], 1 ]
@EndExampleSession


Finally, we can compute the entire decomposition matrix for a given
Schur algebra.

<Verb>
SchurAlgebraDecompositionMatrix( p, n, r )
</Verb>
Here, <A>p</A> is the characteristic and $S(n,r)$ is the Schur algebra
in question, whose modules are the homogeneous polynomial modules for
$GL_n$ in degree <A>r</A>. The rows and columns of the matrix are
indexed by the partitions produced by <K>BoundedPartitions(n,r)</K>.


@BeginExampleSession
gap> SchurAlgebraDecompositionMatrix(2, 4, 5);
[ [ 1, 0, 1, 1, 0, 0 ], [ 0, 1, 0, 0, 0, 1 ], [ 0, 0, 1, 1, 1, 0 ],
[ 0, 0, 0, 1, 1, 0 ], [ 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
gap> BoundedPartitions(4,5);
[ [ 5, 0, 0, 0 ], [ 4, 1, 0, 0 ], [ 3, 2, 0, 0 ], [ 3, 1, 1, 0 ],
[ 2, 2, 1, 0 ], [ 2, 1, 1, 1 ] ]
@EndExampleSession


@Section Symmetric groups

Symmetric group decomposition numbers in positive characteristic
may be obtained from corresponding
decomposition numbers for a Schur algebra Weyl module,
by means of the well known Schur functor. (See
for instance Chapter 6 of <Cite Key="Green"/> for details.)
This method is quite slow. People needing such numbers
for large partitions should use other methods.

<Verb>
SymmetricGroupDecompositionNumbers( p, mu )
</Verb>
This returns a list of the decomposition numbers $[S_\mu : D_\lambda]$
for the dual Specht module $S_\mu$ labeled by a partition <A>mu</A>,
in characteristic <A>p</A>. The simple modules $D_\lambda$ are labeled by
$p$-restricted partitions of the same degree as $\mu$.

@BeginExampleSession
gap> SymmetricGroupDecompositionNumbers(3, [3,2,1]);
[ [ 3, 2, 1 ], 1, [ 2, 2, 2 ], 1, [ 3, 1, 1, 1 ], 1, [ 2, 1, 1, 1, 1 ], 1,
[ 1, 1, 1, 1, 1, 1 ], 1 ]
@EndExampleSession

One can also compute the decomposition matrix for a symmetric group
in positive characteristic.

<Verb>
SymmetricGroupDecompositionMatrix( p, n )
</Verb>
This returns the decomposition matrix for the symmetric group on <A>n</A>
letters, in characteristic <A>p</A>. The rows of the matrix are labeled by
the partitions of <A>n</A> (in the order produced by <K>AllPartitions</K>)
and the columns are labeled by $p$-restricted partitions
of <A>n</A>.

@BeginExampleSession
gap> SymmetricGroupDecompositionMatrix(2, 5);
[ [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 1 ], [ 1, 0, 2 ], [ 1, 0, 1 ],
[ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> AllPartitions(5);
[ [ 5 ], [ 4, 1 ], [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ],
[ 1, 1, 1, 1, 1 ] ]
gap> pRestrictedPartitions(2,5);
[ [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
@EndExampleSession
Note that &GAP; has a built-in <K>Partitions</K> function that
also gives all the
partitions of $n$, but the ordering is different from the ordering
in <K>AllPartitions</K>. To correctly interpret row
labels in the decomposition matrix, one must use the ordering
given in <K>AllPartitions</K>.


@Section The Mullineux correspondence

Computing symmetric group decomposition numbers by means of
the Schur functor naturally produces the
numbers $[S_\mu : D_\lambda]$ for partitions $\mu$ and
$p$-restricted partitions $\lambda$.
Here $S_\mu$ is the dual Specht module labeled
by $\mu$ and $D_\lambda$ is the dual simple module labeled by $\lambda$.

Let $\lambda'$ be the conjugate partition of a partition $\lambda$,
obtained by transposing rows and columns of the corresponding Young
diagram. We have $(S^\mu)^* \cong S_\mu$ for a partition $\mu$
and $D^\lambda ⊗ sgn \cong D_{\lambda'}$ for a $p$-regular partition
$\lambda$, where $S^\mu$ is the usual Specht module and $D^\lambda$ is
the usual simple module, using notation in accord with
<Cite Key="James"/>. The notation $sgn$ here refers to the sign
representation.

Thus it follows that $[S_\mu : D_\lambda] = [S^\mu : D^{Mull(λ)}]$
if $\lambda$ is $p$-restricted. So by sending $\lambda \to Mull(\lambda')$,
one obtains the column labels for the decomposition matrix that appear
in <Cite Key="James"/>.

<Verb>
Mullineux( p, mu )
</Verb>
This returns the partition $Mull(µ)$ corresponding to a given
$p$-regular partition $\mu$ under the Mullineux
map.

@BeginExampleSession
gap> Mullineux(3, [5,4,1,1]);
[ 9, 2 ]
gap> Mullineux(3, [9,2]);
[ 5, 4, 1, 1 ]
@EndExampleSession
<K>pRegularPartitions(p,n)</K> returns a list of the $p$-regular
partitions of $n$, in bijection with the list of $p$-restricted
partitions of $n$ produced by <K>pRestrictedPartitions(p,n)</K>,
using the bijection $\lambda \to  Mull(\lambda')$. Thus, to read a
symmetric group decomposition matrix using $p$-regular partition
notation, one uses the output of <K>pRegularPartitions</K> to index
the columns of the matrix.

Finally, we have a function that computes the conjugate of a pertition.

<Verb>
Conjugate( lambda )
</Verb>
This returns the conjugate (or transpose) of the input partition.

@BeginExampleSession
gap> Conjugate( [4,4,2,1] );
[ 4, 3, 2, 2 ]
gap> Conjugate( [4,3,2,2] );
[ 4, 4, 2, 1 ]
@EndExampleSession




