@Chapter Weyl modules
@ChapterLabel Weyl_modules

This chapter discusses the commands available for computations with
Weyl modules for a given simple simply-connected algebraic group $G$
in positive characteristic $p$. Actually the group $G$ itself never
appears in any of the computations, which take place instead using the
**algebra of distributions** (also known as the **hyperalgebra**) of
$G$, taken over the prime field. One should refer to <Cite
Key="Jantzen"/> for the definition of the algebra of distributions,
and other basic definitions and properties related to Weyl modules.

The algorithms are based on the method of <Cite Key = "Irving"/> (see
also <Cite Key = "Xi"/>) and build on the existing Lie algebra
functionality in &GAP;. In principle, one can work with arbitrary
weights for an arbitrary (simple) root system; in practice, the
functionality is limited by the size of the objects being computed.
If your Weyl module has dimension in the thousands, you may have to
wait a very long time for certain computations to finish.

The package is possibly most useful for doing computations in
characteristic $p$, where $p$ is relatively small relative to the
Coxeter number.  The general theory of Weyl modules <Cite
Key="Jantzen"/> includes a number of basic properties that break down
(or are not known to hold) if the characteristic is too small. In such
cases, explicit computations are often useful.

Recall that a **maximal vector** is a weight vector which is killed by
the positive unipotent radical; equivalently, it is killed by the
positive part of the algebra of distributions.

The main technical idea underlying this package is the following fact:
computing all the maximal vectors in a given Weyl module $V$
classifies the nonzero Weyl modules $W$ for which a nonzero
homomorphism from $W$ into $V$ exists. Such homological information is
a powerful aid to understanding structural properties of the Weyl
module $V$. The implementation of this idea involves a brute force
search through each dominant weight space, examing all linear
combinations (over the prime field) and compiling a list of the ones
which are maximal. This exploits the pleasant fact that for Weyl
modules of small dimension, the dimension of the weight spaces tends
to be manageable.


**Warning.** In most cases, the dimension of space of maximal vectors
of a given dominant weight is either $0$ or $1$. Cases for which there
exist two or more independent maximal vectors of the same weight can
lead to complications, such as a lack of rigidity in the submodule
structure.  Such situations are relatively rare (and interesting); the
smallest example known to the author occurs in Type $D_4$ in the Weyl
module of highest weight $[0,1,0,0]$, as pointed out on page 173 of
<Cite Key = "CPS"/>. (I am grateful to Anton Cox for this reference.)

A Weyl module (as in the previous paragraph) with at least one weight
space containing multiple (linearly independent) maximal vectors is
called **ambiguous**. Extra care is needed when studying ambiguous
Weyl modules.


@Section Creating Weyl modules
There are two functions for creating a Weyl module.

<Verb>
WeylModule( p, wt, type, rank )
WeylModule( V, wt )
</Verb>
In both forms <A>wt</A> is the highest weight of the Weyl module.  The
function with four arguments specifies the characteristic <A>p</A>,
the root system <A>type</A> (a letter in the range A--G) and its
<A>rank</A>. In the second form, with two arguments, the function gets
the characteristic and underlying root system from an existing Weyl
module <A>V</A>.

@BeginExampleSession
gap> V:= WeylModule(3, [3,4], "A", 2);
<Type A2 Weyl module of highest weight [ 3, 4 ] at prime p = 3>
gap> W:= WeylModule(V, [3,0]);
<Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
@EndExampleSession
There is also a category of Weyl modules.
<Verb>
IsWeylModule( V )
</Verb>
This returns true if <A>V</A> is a Weyl module and returns false
otherwise.

@BeginExampleSession
gap> IsWeylModule(W);
true
gap> IsWeylModule(4);
false
@EndExampleSession



@Section Creating submodules, quotients, and subquotients

The &WeylModules; package includes support for working with
submodules, quotients, and certain subquotients of an existing Weyl
module. This can be useful for understanding submodule structure.

There are six forms of the most basic command to create a submodule of
an existing module $V$, where $V$ is a Weyl module, a submodule of a Weyl
module, a quotient, or a subquotient.

<Verb>
SubWeylModule( V, vec )
SubWeylModule( V, lst )
QuotientWeylModule( V, vec )
QuotientWeylModule( V, lst )
SubQuotientWeylModule( V, vec )
SubWeylModule( V, vec )
</Verb>
This returns a submodule of the given ambient object <A>V</A>.
If the second argument <A>vec</A> is a vector, then it returns the
submodule of <A>V</A> generated by that vector. If the second argument
is a list <A>lst</A> then it returns the submodule generated by that
list of vectors.

WARNING: If the dimension of the ambient Weyl module is large, this can
take a very long time.

@BeginExampleSession
gap> V := WeylModule(3,[3,3],"A",2);
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
gap> List(m,Weight);
[ [ 3, 3 ], [ 1, 4 ], [ 4, 1 ], [ 0, 3 ], [ 3, 0 ], [ 1, 1 ] ]
gap> S := SubWeylModule(V, m[6]);
<SubWeylModule of dimension 7, generated by elements 
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ] of weights [ [ 1, 1 ] ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> S2 := SubWeylModule(V, [m[4],m[5]]);
<SubWeylModule of dimension 13, generated by elements 
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0 ] of weights [ [ 0, 3 ], [ 3, 0 ] 
 ]>, in
<Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
@EndExampleSession



There is another function that creates submodules of an existing
Weyl module or quotient Weyl module, as a direct sum of a list of
existing submodules. The submodules in the list must be linearly
independent.

<Verb>
SubWeylModuleDirectSum( V, lst )
</Verb>
This returns the direct sum of the given list of submodules.

@BeginExampleSession
gap> V := WeylModule(2,[2,0],"G",2);
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> m := MaximalVectors(V);
[ 1*v0, y1*v0, y4*v0 ]
gap> List(m,Weight);
[ [ 2, 0 ], [ 0, 1 ], [ 1, 0 ] ]
gap> S1 := SubWeylModule(V,m[2]);
<SubWeylModule of dimension 14, generated by elements [ y1*v0 ] of weights 
[ [ 0, 1 ] ]>, in
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> S2 := SubWeylModule(V,m[3]);
<SubWeylModule of dimension 6, generated by elements [ y4*v0 ] of weights 
[ [ 1, 0 ] ]>, in
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> D := SubWeylModuleDirectSum(V,[S1,S2]);
<SubWeylModule of dimension 20, generated by elements 
[ y1*v0, y4*v0 ] of weights [ [ 0, 1 ], [ 1, 0 ] ]>, in
<Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
@EndExampleSession
In the above example, the given Weyl module of type $G_2$ in
characteristic $2$ has two maximal vectors of different weights in the
socle, so it is possible to form the direct sum of the submodules thay
generate. In this case, the direct sum coincides with the socle.
(The <K>SocleWeyl</K> command calls the above to produce
the socle directly.)  

We also have categories of submodules.

<Verb>
IsSubWeylModule ( X )
IsSubQuotientWeylModule( X )
</Verb>
These functions return true if the object is a submodule of an existing
Weyl module or existing quotient Weyl module, respectively, and return
false otherwise.

@BeginExampleSession
gap> IsSubWeylModule(D);
true
gap> IsSubQuotientWeylModule(D);
false
@EndExampleSession
Here, we assume that $D$ is as defined in the preceding example.


@Section Creating quotient Weyl modules

Quotients of an existing Weyl module by a submodule are supported.

<Verb>
QuotientWeylModule( S )
</Verb>
This returns the quotient module $V/S$, where $V$ is the ambient
Weyl module of which $S$ is a submodule.

@BeginExampleSession
gap> Q := QuotientWeylModule(D);
<Quotient of Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
@EndExampleSession
In the above, it is assumed that $D$ is the submodule constructed in
the example of the previous section.

There is also a category of quotient Weyl modules.

<Verb>
gap> IsQuotientWeylModule( Q )
</Verb>
which returns true if $Q$ is a quotient Weyl module, and returns false
otherwise.