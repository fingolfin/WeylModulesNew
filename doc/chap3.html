<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (WeylModules) - Chapter 3: Characters and structure</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X8216AAFD7A08A4C4" name="X8216AAFD7A08A4C4"></a></p>
<div class="ChapSects"><a href="chap3.html#X8216AAFD7A08A4C4">3 <span class="Heading">Characters and structure</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7CCB304878D99999">3.1 <span class="Heading">Characters</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X81B34497828786F5">3.2 <span class="Heading">Decomposition numbers</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X84A271A87AEDFEFF">3.3 <span class="Heading">The maximal submodule and simple quotient</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X797CCD317F9335F3">3.4 <span class="Heading">The socle series</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7AC6F00B84D3A8D1">3.5 <span class="Heading">Testing membership</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X828EC5987B937531">3.6 <span class="Heading">The ambient module</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8367EF0D80FD6F87">3.7 <span class="Heading">Acting on a vector</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Characters and structure</span></h3>

<p>Given a Weyl module, one can compute certain structural information such as its socle series or its unique simple quotient. One can also compute characters of Weyl modules, quotients, submodules, and subquotients. Characters of tensor products are also supported, in a limited way.</p>

<p>In particular, it is possible to compute all the simple characters for a given root system and characteristic, provided the modules do not get too large. And one can compute the decomposition numbers for a given Weyl module, again assuming it is not too large.</p>

<p><a id="X7CCB304878D99999" name="X7CCB304878D99999"></a></p>

<h4>3.1 <span class="Heading">Characters</span></h4>

<p>The most basic command to compute the character of an existing module is the following.</p>


<pre class="normal">

Character( V )

</pre>

<p>This returns a list consisting of each weight of <var class="Arg">V</var> followed by its corresponding weight space dimension. The module <var class="Arg">V</var> must be a Weyl module, a submodule, a quotient, or a subquotient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= WeylModule(3, [3,0], "A", 2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Character(V);</span>
[ [ 3, 0 ], 1, [ 1, 1 ], 1, [ 2, -1 ], 1, [ -1, 2 ], 1, [ 0, 0 ], 1, 
  [ -3, 3 ], 1, [ 1, -2 ], 1, [ -2, 1 ], 1, [ -1, -1 ], 1, [ 0, -3 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:= MaximalSubmodule(V);</span>
&lt;SubWeylModule of dimension 7, generated by elements [ y1*v0 ] of weights 
[ [ 1, 1 ] ]&gt;, in
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Character(S);</span>
[ [ 1, 1 ], 1, [ -1, 2 ], 1, [ 2, -1 ], 1, [ 0, 0 ], 1, [ -2, 1 ], 1, 
  [ 1, -2 ], 1, [ -1, -1 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Character(QuotientWeylModule(S));</span>
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
</pre></div>

<p>Simple characters for a given highest (dominant) weight are computed by one of the following.</p>


<pre class="normal">

SimpleCharacter( p, wt, type, rk )
SimpleCharacter( V, wt )

</pre>

<p>These return the simple character of the given highest weight. In the second form, <var class="Arg">V</var> must be an existing Weyl module, and the characteristic <var class="Arg">p</var>, the type <var class="Arg">type</var>, and the rank <var class="Arg">rk</var> are looked up in <var class="Arg">V</var>. (Note: In the second form, the highest weight <var class="Arg">wt</var> does not have to agree with the highest weight of <var class="Arg">V</var>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">char:= SimpleCharacter(3, [3,0], "A", 2);</span>
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= WeylModule(2, [1,0], "G", 2);</span>
&lt;Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">char := SimpleCharacter(V,[0,2]);</span>
[ [ 0, 2 ], 1, [ 6, -2 ], 1, [ 2, 0 ], 1, [ -2, 2 ], 1, [ -6, 4 ], 1, 
  [ 4, -2 ], 1, [ 0, 0 ], 2, [ 6, -4 ], 1, [ -4, 2 ], 1, [ 2, -2 ], 1, 
  [ -2, 0 ], 1, [ -6, 2 ], 1, [ 0, -2 ], 1 ]
</pre></div>

<p>Characters can be multiplied. Given two characters (of modules) for the same root system, it is possible to compute the character of the tensor product of the modules. This is used internally in implementing Steinberg's tensor product theorem.</p>


<pre class="normal">

ProductCharacter( ch1, ch2 )

</pre>

<p>Returns the product character.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[1,1],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 1, 1 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ch1 := SimpleCharacter(V,[0,1]);</span>
[ [ 0, 1 ], 1, [ 1, -1 ], 1, [ -1, 0 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prod := ProductCharacter(ch1,ch1);</span>
[ [ 0, 2 ], 1, [ 1, 0 ], 2, [ -1, 1 ], 2, [ 2, -2 ], 1, [ 0, -1 ], 2, 
  [ -2, 0 ], 1 ]
</pre></div>

<p>It is possible to subtract characters. The result is not in general a character. The function <code class="keyw">DecomposeCharacter</code> uses character subtraction to decompose a given character into its simple characters with multiplicity. This is used internally by the <code class="keyw">DecompositionNumbers</code> function to compute the decomposition numbers of a Weyl module.</p>


<pre class="normal">

DifferenceCharacter( ch1, ch2 )
DecomposeCharater( ch, p, type, rk )

</pre>

<p>The first function returns the virtual character of the difference of its inputs. The second computes the decomposition numbers of the given charaacter <var class="Arg">ch</var> for the root system of type <var class="Arg">type</var>, rank <var class="Arg">rk</var>, and characteristic <var class="Arg">p</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DecomposeCharacter(prod,3,"A",2);</span>
[ [ 0, 2 ], 1, [ 1, 0 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[1,1],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 1, 1 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dn := DecomposeCharacter(Character(V),3,"A",2);</span>
[ [ 1, 1 ], 1, [ 0, 0 ], 1 ]
</pre></div>

<p>In the first example, <code class="keyw">prod</code> is the product character computed in the previous example; thus we have decomposed a tensor product. In the last example, <code class="keyw">dn</code> gives the decomposition numbers of the Weyl module of highest weight [1,1] in characteristic <span class="Math">3</span>. (This can also be computed more directly by the <code class="keyw">DecompositionNumbers</code> function.)</p>

<p><a id="X81B34497828786F5" name="X81B34497828786F5"></a></p>

<h4>3.2 <span class="Heading">Decomposition numbers</span></h4>

<p>The decomposition numbers of a given Weyl module can be computed.</p>


<pre class="normal">

DecompositionNumbers( V )

</pre>

<p>This returns a list consisting of each highest weight of a simple composition factor followed by its composition factor multiplicity. It is assumed that <var class="Arg">V</var> is an existing Weyl module. (There are other ways to compute this, so the function is provided as a convenience for the user.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[3,3],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionNumbers(V);</span>
[ [ 3, 3 ], 1, [ 1, 4 ], 1, [ 4, 1 ], 1, [ 0, 3 ], 1, [ 3, 0 ], 1, [ 1, 1 ], 
  1, [ 0, 0 ], 2 ]
</pre></div>

<p><a id="X84A271A87AEDFEFF" name="X84A271A87AEDFEFF"></a></p>

<h4>3.3 <span class="Heading">The maximal submodule and simple quotient</span></h4>

<p>A given Weyl module <var class="Arg">V</var> always has a unique maximal submodule. The package supports computing this important submodule.</p>


<pre class="normal">

MaximalSubmodule( V )

</pre>

<p>This returns the submodule generated by all proper submodules.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[3,0],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := MaximalSubmodule(V);</span>
&lt;SubWeylModule of dimension 7, generated by elements [ y1*v0 ] of weights 
[ [ 1, 1 ] ]&gt;, in
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
</pre></div>

<p>Here, the Weyl module is the third symmetric power of the natural module. It has dimension <span class="Math">10</span>. The maximal submodule makes a list of its generators available to the <code class="keyw">Generators</code> function for further computation.</p>

<p>Let's check that the difference character of the Weyl character and its maximal submodule coincides with the corresponding simple character.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DifferenceCharacter(Character(V),Character(S));</span>
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := SimpleCharacter(3,[3,0],"A",2);</span>
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
</pre></div>

<p>We can also compute the corresponding simple quotient of <var class="Arg">V</var> by its maximal submodule, as a quotient Weyl module. The general form is</p>


<pre class="normal">

SimpleQuotient( V )

</pre>

<p>This returns the simple quotient of a Weyl module <var class="Arg">V</var> by its unique maximal submodule.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[3,0],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := SimpleQuotient(V);</span>
&lt;Quotient of Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ch := Character(Q);</span>
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
</pre></div>

<p>Notice that this gives yet another way to calculate simple characters.</p>

<p><a id="X797CCD317F9335F3" name="X797CCD317F9335F3"></a></p>

<h4>3.4 <span class="Heading">The socle series</span></h4>

<p>The package supports computing the socle series of a given Weyl module, or of a given quotient Weyl module.</p>


<pre class="normal">

SocleSeries( V )

</pre>

<p>This returns the socle series, as a list of submodules (or a list of subquotients, if <var class="Arg">V</var> is a quotient Weyl module).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[3,0],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SocleSeries(V);</span>
[ &lt;SubWeylModule of dimension 7, generated by elements [ y1*v0 ] of weights 
    [ [ 1, 1 ] ]&gt;, in
    &lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt;, 
  &lt;SubWeylModule of dimension 10, generated by elements 
    [ y1*v0, 1*v0 ] of weights [ [ 1, 1 ], [ 3, 0 ] ]&gt;, in
    &lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3&gt; ]
</pre></div>

<p>The socle series is computed by internally applying the following functions, which may be useful in other situations as well.</p>


<pre class="normal">

SocleWeyl( V )
NextSocle( S )
GensNextSocle( S )

</pre>

<p>The first function returns the socle of its argument. The second function returns the next socle layer, assuming that <var class="Arg">S</var> is a submodule. That is, <code class="keyw">NextSocle</code> returns the submodule that maps onto the socle of the quotient <var class="Arg">V</var>/<var class="Arg">S</var>, where <var class="Arg">V</var> is the ambient module. The third function returns a list of generators of the next socle layer for the given submodule <var class="Arg">S</var>. For the first two functions, <var class="Arg">V</var> must be either a Weyl module or a quotient Weyl module. The third function is only available for a Weyl module.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">soc := SocleWeyl(V);</span>
&lt;SubWeylModule of dimension 7, generated by elements 
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ] of weights [ [ 1, 1 ] ]&gt;, in
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[3,3],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := MaximalVectors(V);</span>
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SubWeylModule(V,[m[4],m[5]]);</span>
&lt;SubWeylModule of dimension 13, generated by elements 
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0 ] of weights [ [ 0, 3 ], [ 3, 0 ] 
 ]&gt;, in
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NextSocle(S);</span>
&lt;SubWeylModule of dimension 14, generated by elements 
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, y1*y2*y3^(2)*v0 ] of weights 
[ [ 0, 3 ], [ 3, 0 ], [ 0, 0 ] ]&gt;, in
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GensNextSocle(S);</span>
[ y1*y2*y3^(2)*v0 ]
</pre></div>

<p><a id="X7AC6F00B84D3A8D1" name="X7AC6F00B84D3A8D1"></a></p>

<h4>3.5 <span class="Heading">Testing membership</span></h4>

<p>It is possible to test a given weight vector for membership in a submodule or a subquotient.</p>


<pre class="normal">

IsWithin( S, vec )

</pre>

<p>This returns true if the given vector <var class="Arg">vec</var> is in the submodule <var class="Arg">S</var>, and returns false otherwise. The vector <var class="Arg">vec</var> must be in the ambient module. Here, <var class="Arg">S</var> can be either a submodule of a Weyl module, or a submodule of a quotient Weyl module.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(3,[3,3],"A",2);</span>
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := MaximalSubmodule(V);</span>
&lt;SubWeylModule of dimension 57, generated by elements 
[ y1*v0, y2*v0, y1^(3)*y2^(3)*v0+y3^(3)*v0 ] of weights 
[ [ 1, 4 ], [ 4, 1 ], [ 0, 0 ] ]&gt;, in
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := MaximalVectors(V);</span>
[ 1*v0, y1*v0, y2*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWithin(M,m[1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWithin(M,m[2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWithin(M, m[2]+2*m[3]);</span>
true
</pre></div>

<p><a id="X828EC5987B937531" name="X828EC5987B937531"></a></p>

<h4>3.6 <span class="Heading">The ambient module</span></h4>

<p>Submodules and quotient modules remember the original ambient Weyl modules from which they were constructed. Subquotients, which are always constructed as submodules in some quotient Weyl module, know the ambient quotient in which they were constructed. The following functions return the ambient module to make it available for further computations.</p>


<pre class="normal">

AmbientWeylModule( M )
AmbientQuotient( S )

</pre>

<p>In the first function, <var class="Arg">M</var> can be either a quotient Weyl module or a submodule of a Weyl module, and the ambient Weyl module is returned. In the second function, <var class="Arg">M</var> must be a submodule of some existing quotient Weyl module, and the ambient quotient is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := WeylModule(2,[0,1,0,0],"D",4);</span>
&lt;Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SocleWeyl(V);</span>
***** WARNING: Ambiguous module detected *****
&lt;SubWeylModule of dimension 2, generated by elements 
[ y5*y10*v0+y6*y9*v0, y2*y11*v0+y5*y10*v0+y12*v0 ] of weights 
[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]&gt;, in
&lt;Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientWeylModule(S);</span>
&lt;Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2&gt;
</pre></div>

<p><a id="X8367EF0D80FD6F87" name="X8367EF0D80FD6F87"></a></p>

<h4>3.7 <span class="Heading">Acting on a vector</span></h4>

<p>It is sometimes useful to act on a given vector by an element of the hyperalgebra (algebra of distributions). One needs to use a builtin <strong class="pkg">GAP</strong> function to construct elements of the hyperalgebra.</p>


<pre class="normal">

ActOn( V, u, vec )

</pre>

<p>This returns the result, in the ambient module <var class="Arg">V</var>, of letting <var class="Arg">u</var> act on the given vector <var class="Arg">vec</var>, where <var class="Arg">V</var> is either a Weyl module or a quotient Weyl module.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= WeylModule(2, [1,0], "G", 2);</span>
&lt;Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= TheLieAlgebra(V);</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= BasisVecs(V);</span>
[ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LatticeGeneratorsInUEA(L);</span>
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ActOn(V, g[1]^2 + g[7], b[1]);</span>
0*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ActOn(V, g[1]*g[6], b[1]);</span>
y1*y6*v0
</pre></div>

<p>Note that <code class="keyw">LatticeGeneratorsInUEA</code> is an existing <strong class="pkg">GAP</strong> command.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
